# -*- coding: utf-8 -*-
"""Copy of Copy of Copy of Welcome to Colaboratory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KJMQe9AhtrFS9-nNZp2ibSUiIi_Fvg7r

<p><img alt="Colaboratory logo" height="45px" src="/img/colab_favicon.ico" align="left" hspace="10px" vspace="0px"></p>

<h1>What is Colaboratory?</h1>

Colaboratory, or 'Colab' for short, allows you to write and execute Python in your browser, with 
- Zero configuration required
- Free access to GPUs
- Easy sharing

Whether you're a <strong>student</strong>, a <strong>data scientist</strong> or an <strong>AI researcher</strong>, Colab can make your work easier. Watch <a href="https://www.youtube.com/watch?v=inN8seMm7UI">Introduction to Colab</a> to find out more, or just get started below!

## <strong>Getting started</strong>

The document that you are reading is not a static web page, but an interactive environment called a <strong>Colab notebook</strong> that lets you write and execute code.

For example, here is a <strong>code cell</strong> with a short Python script that computes a value, stores it in a variable and prints the result:
"""

seconds_in_a_day = 24 * 60 * 60
seconds_in_a_day

"""To execute the code in the above cell, select it with a click and then either press the play button to the left of the code, or use the keyboard shortcut 'Command/Ctrl+Enter'. To edit the code, just click the cell and start editing.

Variables that you define in one cell can later be used in other cells:
"""

seconds_in_a_week = 7 * seconds_in_a_day
seconds_in_a_week

"""Colab notebooks allow you to combine <strong>executable code</strong> and <strong>rich text</strong> in a single document, along with <strong>images</strong>, <strong>HTML</strong>, <strong>LaTeX</strong> and more. When you create your own Colab notebooks, they are stored in your Google Drive account. You can easily share your Colab notebooks with co-workers or friends, allowing them to comment on your notebooks or even edit them. To find out more, see <a href="/notebooks/basic_features_overview.ipynb">Overview of Colab</a>. To create a new Colab notebook you can use the File menu above, or use the following link: <a href="http://colab.research.google.com#create=true">Create a new Colab notebook</a>.

Colab notebooks are Jupyter notebooks that are hosted by Colab. To find out more about the Jupyter project, see <a href="https://www.jupyter.org">jupyter.org</a>.

## Data science

With Colab you can harness the full power of popular Python libraries to analyse and visualise data. The code cell below uses <strong>numpy</strong> to generate some random data, and uses <strong>matplotlib</strong> to visualise it. To edit the code, just click the cell and start editing.
"""

import numpy as np
from matplotlib import pyplot as plt

ys = 200 + np.random.randn(100)
x = [x for x in range(len(ys))]

plt.plot(x, ys, '-')
plt.fill_between(x, ys, 195, where=(ys > 195), facecolor='g', alpha=0.6)

plt.title("Sample Visualization")
plt.show()

"""You can import your own data into Colab notebooks from your Google Drive account, including from spreadsheets, as well as from GitHub and many other sources. To find out more about importing data, and how Colab can be used for data science, see the links below under <a href="#working-with-data">Working with data</a>.

## Machine learning

With Colab you can import an image dataset, train an image classifier on it, and evaluate the model, all in just <a href="https://colab.research.google.com/github/tensorflow/docs/blob/master/site/en/tutorials/quickstart/beginner.ipynb">a few lines of code</a>. Colab notebooks execute code on Google's cloud servers, meaning you can leverage the power of Google hardware, including <a href="#using-accelerated-hardware">GPUs and TPUs</a>, regardless of the power of your machine. All you need is a browser.

Colab is used extensively in the machine learning community with applications including:
- Getting started with TensorFlow
- Developing and training neural networks
- Experimenting with TPUs
- Disseminating AI research
- Creating tutorials

To see sample Colab notebooks that demonstrate machine learning applications, see the <a href="#machine-learning-examples">machine learning examples</a> below.

## More resources

### Working with notebooks in Colab
- [Overview of Colaboratory](/notebooks/basic_features_overview.ipynb)
- [Guide to markdown](/notebooks/markdown_guide.ipynb)
- [Importing libraries and installing dependencies](/notebooks/snippets/importing_libraries.ipynb)
- [Saving and loading notebooks in GitHub](https://colab.research.google.com/github/googlecolab/colabtools/blob/master/notebooks/colab-github-demo.ipynb)
- [Interactive forms](/notebooks/forms.ipynb)
- [Interactive widgets](/notebooks/widgets.ipynb)
- <img src="/img/new.png" height="20px" align="left" hspace="4px" alt="New"></img>
 [TensorFlow 2 in Colab](/notebooks/tensorflow_version.ipynb)

<a name="working-with-data"></a>
### Working with data
- [Loading data: Drive, Sheets and Google Cloud Storage](/notebooks/io.ipynb) 
- [Charts: visualising data](/notebooks/charts.ipynb)
- [Getting started with BigQuery](/notebooks/bigquery.ipynb)

### Machine learning crash course
These are a few of the notebooks from Google's online machine learning course. See the <a href="https://developers.google.com/machine-learning/crash-course/">full course website</a> for more.
- [Intro to Pandas](/notebooks/mlcc/intro_to_pandas.ipynb)
- [TensorFlow concepts](/notebooks/mlcc/tensorflow_programming_concepts.ipynb)
- [First steps with TensorFlow](/notebooks/mlcc/first_steps_with_tensor_flow.ipynb)
- [Intro to neural nets](/notebooks/mlcc/intro_to_neural_nets.ipynb)
- [Intro to sparse data and embeddings](/notebooks/mlcc/intro_to_sparse_data_and_embeddings.ipynb)

<a name="using-accelerated-hardware"></a>
### Using accelerated hardware
- [TensorFlow with GPUs](/notebooks/gpu.ipynb)
- [TensorFlow with TPUs](/notebooks/tpu.ipynb)

<a name="machine-learning-examples"></a>

## Machine learning examples

To see end-to-end examples of the interactive machine-learning analyses that Colaboratory makes possible, take a look at these tutorials using models from <a href="https://tfhub.dev">TensorFlow Hub</a>.

A few featured examples:

- <a href="https://tensorflow.org/hub/tutorials/tf2_image_retraining">Retraining an Image Classifier</a>: Build a Keras model on top of a pre-trained image classifier to distinguish flowers.
- <a href="https://tensorflow.org/hub/tutorials/tf2_text_classification">Text Classification</a>: Classify IMDB film reviews as either <em>positive</em> or <em>negative</em>.
- <a href="https://tensorflow.org/hub/tutorials/tf2_arbitrary_image_stylization">Style Transfer</a>: Use deep learning to transfer style between images.
- <a href="https://tensorflow.org/hub/tutorials/retrieval_with_tf_hub_universal_encoder_qa">Multilingual Universal Sentence Encoder Q&amp;A</a>: Use a machine-learning model to answer questions from the SQuAD dataset.
- <a href="https://tensorflow.org/hub/tutorials/tweening_conv3d">Video Interpolation</a>: Predict what happened in a video between the first and the last frame.
"""

import pandas as pd
import numpy as np
import math
import networkx as nx
import random
df=pd.read_csv('/content/SaO_Optilandia_locations.csv')
df1=pd.read_csv('/content/SaO_Optilandia_links.csv')
#a=np.array(df.loc[df['is_depot']==True])
coordinates=np.array(df[['x', 'y']])
customers=np.array(df.loc[df['is_customer']==True])
demands=[]
for i in range(len(customers)):
  customer=customers[i]
  demand=customer[5]-customer[6]
  demands.append({'id':customer[0],'demand':demand})

custo_ids=[]
for i in range(len(demands)):
  custo_ids.append(demands[i]['id'])
under_threshold=[]
for i in range(len(customers)):
  customer=customers[i]
  demand=customer[5]-customer[6]
  if(customer[6]<customer[5]*0.15):
    under_threshold.append({'id':customer[0],'demand':demand})

links=np.array(df1[['id1', 'id2']])

distances=[]
for i in range(len(coordinates)):
  distances.append([])
  for j in range(len(coordinates)):

    dist=math.sqrt((coordinates[i][0]-coordinates[j][0])**2+(coordinates[i][1]-coordinates[j][1])**2)
    distances[i].append(dist)
edges=[]
for i in range(len(links)):
  edges.append([])
  for j in range(len(links)):
    if i==links[j][0]:
      edges[i].append(links[j][1])
#print(edges)
g = nx.Graph()
for i in range(len(edges)):
  
  for j in range(len(edges[i])):
    one=edges[i][j]
    g.add_edge(i,edges[i][j],weight=distances[i][one])


depots=[{'id':523},{'id':124},{'id':373},{'id':116}]
lorries=[{'lorry_id': '523-0', 'capacity': 5, 'cpm': 1.0, 'cptm': 1.5, 'loc': [], 'location': 523, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '523-1', 'capacity': 5, 'cpm': 1.0, 'cptm': 1.5, 'loc': [], 'location': 523, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '523-2', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 523, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '523-3', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 523, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '523-4', 'capacity': 22, 'cpm': 2.0, 'cptm': 0.5, 'loc': [], 'location': 523, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '124-0', 'capacity': 5, 'cpm': 1.0, 'cptm': 1.5, 'loc': [], 'location': 124, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '124-1', 'capacity': 5, 'cpm': 1.0, 'cptm': 1.5, 'loc': [], 'location': 124, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '124-2', 'capacity': 5, 'cpm': 1.0, 'cptm': 1.5, 'loc': [], 'location': 124, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '124-3', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 124, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '124-4', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 124, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '124-5', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 124, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '124-6', 'capacity': 22, 'cpm': 2.0, 'cptm': 0.5, 'loc': [], 'location': 124, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '124-7', 'capacity': 22, 'cpm': 2.0, 'cptm': 0.5, 'loc': [], 'location': 124, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-0', 'capacity': 5, 'cpm': 1.0, 'cptm': 1.5, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-1', 'capacity': 5, 'cpm': 1.0, 'cptm': 1.5, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-2', 'capacity': 5, 'cpm': 1.0, 'cptm': 1.5, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-3', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-4', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-5', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-6', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-7', 'capacity': 22, 'cpm': 2.0, 'cptm': 0.5, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-8', 'capacity': 22, 'cpm': 2.0, 'cptm': 0.5, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '373-9', 'capacity': 22, 'cpm': 2.0, 'cptm': 0.5, 'loc': [], 'location': 373, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '116-0', 'capacity': 5, 'cpm': 1.0, 'cptm': 1.5, 'loc': [], 'location': 116, 'current': 0, 'stops': 0, 'miles': 0}, {'lorry_id': '116-1', 'capacity': 12, 'cpm': 1.5, 'cptm': 1.0, 'loc': [], 'location': 116, 'current': 0, 'stops': 0, 'miles': 0}]
costs={'523-0': [1.0, 1.5], '523-1': [1.0, 1.5], '523-2': [1.5, 1.0], '523-3': [1.5, 1.0], '523-4': [2.0, 0.5], '124-0': [1.0, 1.5], '124-1': [1.0, 1.5], '124-2': [1.0, 1.5], '124-3': [1.5, 1.0], '124-4': [1.5, 1.0], '124-5': [1.5, 1.0], '124-6': [2.0, 0.5], '124-7': [2.0, 0.5], '373-0': [1.0, 1.5], '373-1': [1.0, 1.5], '373-2': [1.0, 1.5], '373-3': [1.5, 1.0], '373-4': [1.5, 1.0], '373-5': [1.5, 1.0], '373-6': [1.5, 1.0], '373-7': [2.0, 0.5], '373-8': [2.0, 0.5], '373-9': [2.0, 0.5], '116-0': [1.0, 1.5], '116-1': [1.5, 1.0]}

def deliver(v,c,journey):
  #customers=ds=nx.single_source_dijkstra(g,source=lorries[v]['location'],target=c,weight='weight')
  
  if(len(demands))<3:
    print('start')
  given_to_others=0
  
  available=lorries[v]['current']-demands[c]['demand']
  for i in range(1,len(journey)-1):

    if(journey[i] in custo_ids):
      id=journey[i]
      index=custo_ids.index(id)
      #total+=demands[index]['demand']
      if(lorries[v]['stops']<4 and available>=demands[index]['demand'] and i<len(journey)-1):
         distance=nx.single_source_dijkstra(g,source=lorries[v]['location'],target=demands[index]['id'])[0]
         lorries[v]['loc'].append([demands[index]['id'],-demands[index]['demand']])
         available-=demands[index]['demand']
            #diff=lorries[v]['current']-demands[index]['demand']
         given_to_others+=demands[index]['demand']
         demands[index]['demand']=0

        
         #del custo_ids[custo_ids.index(demands[index]['id'])]
         
         lorries[v]['location']=demands[index]['id']
         lorries[v]['stops']+=1
         lorries[v]['miles']+=distance
         del demands[index]
         del custo_ids[index]
      elif(lorries[v]['stops']<4 and available<demands[index]['demand'] and i<len(journey)-1 and available>0):
        distance=nx.single_source_dijkstra(g,source=lorries[v]['location'],target=demands[index]['id'])[0]
        demands[index]['demand']-=available
        lorries[v]['loc'].append([demands[index]['id'],-available])
        given_to_others+=available
        available=0
        lorries[v]['stops']+=1
        lorries[v]['miles']+=distance
        lorries[v]['location']=demands[index]['id']

      
  lorries[v]['current']-=demands[c]['demand']
  distance=nx.single_source_dijkstra(g,source=lorries[v]['location'],target=demands[c]['id'])[0]
  lorries[v]['loc'].append([demands[c]['id'],-demands[c]['demand']])
  demands[c]['demand']=0
  lorries[v]['location']=demands[c]['id']
  lorries[v]['stops']+=1
  lorries[v]['miles']+=distance
  del demands[c]
  del custo_ids[c]
  if len(demands)<3:
    print('hey')
  lorries[v]['current']-=given_to_others


  #print(lorries[v])





  
#deliver(v,c,customers)
def nearby_depot(location):
  closest=depots[0]['id']
  distance=nx.single_source_dijkstra(g,source=location,target=depots[0]['id'],weight='weight')[0]
  for i in range(len(depots)):
    
    current_distance=nx.single_source_dijkstra(g,source=location,target=depots[i]['id'],weight='weight')[0]
    if(current_distance<distance):
      closest=depots[i]['id']
      distance=current_distance
  return closest

def depot_and_deliver(v,c,end):
  
  #lorries[v]['current']=0
  #choose a random depot
  #depot=random.randint(0,len(depots)-1)
  #depot_id=depots[depot]['id']
  depot=nearby_depot(lorries[v]['location'])
  journey_to_depot=journey=nx.shortest_path(g,source=lorries[v]['location'],target=depot,weight='weight')
  for i in range(len(journey_to_depot)):
    if(journey_to_depot[i] in custo_ids):
      indice=custo_ids.index(journey_to_depot[i])
      if(lorries[v]['stops']>lorries[v]['current']>=demands[indice]['demand']):
        lorries[v]['current']-=demands[indice]['demand']
        lorries[v]['loc'].append([demands[indice]['id'],-demands[indice]['demand']])
        demands[indice]['demand']=0
        lorries[v]['location']=demands[indice]['id']
      elif(lorries[v]['current']<demands[indice]['demand']):
        demands[indice]['demand']-=lorries[v]['current']
        lorries[v]['loc'].append([demands[indice]['id'],-lorries[v]['current']])
        lorries[v]['current']=0
        lorries[v]['location']=demands[indice]['id']
  #This is once it gets to depot
  lorries[v]['location']=depot
  load=lorries[v]['capacity']-lorries[v]['current']
  lorries[v]['current']=lorries[v]['capacity']
  lorries[v]['loc'].append([depot,load])
  lorries[v]['location']=depot
  
  journey=nx.shortest_path(g,source=depot,target=end,weight='weight')
  #The path not satisfied.
  deliver(v,c,journey)
  #print(lorries[v])
#depot_and_deliver()

def have_delivered(lorries):
  journeys=[]
  for i in range(len(lorries)):
    if(len(lorries[i]['loc'])>1):
      
      journeys.append({'lorry_id':lorries[i]['lorry_id'],'loc':lorries[i]['loc']})
  return journeys
def back_to_depot(have_worked):
  for i in range (len(have_worked)):
    start=have_worked[i]['loc'][0][0]
    have_worked[i]['loc'].append([start,0])
  return have_worked

def pop():
    total_d=0
   
    def pers(total_d):
      
        
        while len(custo_ids)>0:
           
          #not_full=0
          #for i in range(len(demands)):
            #if(demands[i]['demand'])>0:
              #not_full+=1
          
           #else:
            #print(total_d)
            
            
            
            v=random.randint(0,len(lorries)-1)
            c=random.randint(0,len(custo_ids)-1)
            end=custo_ids[c]
            if(len(lorries[v]['loc'])==0):
              
              lorries[v]['current']=lorries[v]['capacity']
              lorries[v]['loc'].append([lorries[v]['location'],lorries[v]['current']])
            

       
            if lorries[v]['current']>0 and lorries[v]['current']>=demands[c]['demand']:
              journey=nx.shortest_path(g,source=lorries[v]['location'],target=end,weight='weight')
              
              deliver(v,c,journey)
           
              
              #pers(total_d)
            
            elif lorries[v]['current']==0 or lorries[v]['current']<demands[c]['demand']:
              depot_and_deliver(v,c,end)
              
              #pers(total_d)
            #for i in range(len(demands)):
              #if(demands[i]['demand'])==0:
                #del custo_ids[i]
                #del demands[i]
            #print(len(custo_ids))
        have_worked=have_delivered(lorries)
        back_to_depot(have_worked)

        #print(lorries)
        return have_worked
    
    return pers(total_d) 

#pop()
#print(len(lorries[0]['loc']))
#solution=pop()
def evaluate(solution):
  sols=pop()
  total_cost=0
  for i in range(len(solution)):
    lorry=solution[i]
    for j in range(len(lorry['loc'])-1):
      from_node=lorry['loc'][j][0]
      to_node=lorry['loc'][j+1][0]
      distance=nx.single_source_dijkstra(g,source=from_node,target=to_node,weight='weight')[0]
      if(lorry['loc'][j][1]>0):
        volume=lorry['loc'][j][1]
      else:
        volume-=lorry['loc'][j][1]
      cpm=costs[lorry['lorry_id']][0]
      cptm=costs[lorry['lorry_id']][1]
      total_cost+=(distance*cpm)+(cptm*volume)
    return total_cost

#evaluate(solution)
under_ids=[]
for i in range(len(under_threshold)):
  under_ids.append(under_threshold[i]['id'])
def deliver1(v,c,customer_id,target):
  available=lorries[v]['current']-demands[target]['demand']
  given_to_others=0
  miles=nx.single_source_dijkstra(g,source=lorries[v]['location'],target=customer_id,weight='weight')
  for i in range(1,len(miles[1])):
    
    if(i<len(miles[1])-1):
      if(miles[1][i] in custo_ids ):
        index=custo_ids.index(miles[1][i])
       

        if(lorries[v]['stops']<4 and available>=demands[index]['demand']):

         lorries[v]['location']=demands[index]['id']
         lorries[v]['stops']+=1
         given_to_others+=demands[index]['demand']
         available-=demands[index]['demand']
         lorries[v]['loc'].append([demands[index]['id'],-demands[index]['demand']])
         demands[index]['demand']=0
         del demands[index]
         del custo_ids[index]
         if(miles[1][i] in under_ids):
           indice=under_ids.index(miles[1][i])
           del under_threshold[indice]
           del under_ids[indice]
        elif(lorries[v]['stops']<4 and available<demands[index]['demand']):
         lorries[v]['location']=demands[index]['id']
         lorries[v]['stops']+=1
         given_to_others+=available
         if(demands[index]['id'] in under_ids):
           indice=under_ids.index(demands[index]['id'])
           under_threshold[indice]['demand']-=available
           demands[index]['demand']-=available
           lorries[v]['loc'].append(demands[index]['id'],-available)
           available=0
    if(i==len(miles[1])-1):
        
      lorries[v]['miles']+=miles[0]
      lorries[v]['location']=customer_id
      if(len(under_threshold)>0):
        lorries[v]['current']-=(under_threshold[c]['demand']+given_to_others)
        lorries[v]['loc'].append([customer_id,-under_threshold[c]['demand']])
        under_threshold[c]['demand']=0
        lorries[v]['stops']+=1
        del under_threshold[c]
        del under_ids[c]
        del demands[target]
        del custo_ids[target]
        
      elif(len(under_threshold)==0):
        lorries[v]['current']-=(demands[target]['demand']+given_to_others)
        lorries[v]['loc'].append([demands[target]['id'],-demands[target]['demand']])
        demands[target]['demand']=0
        lorries[v]['stops']+=1
        del demands[target]
        del custo_ids[target]

def depot_and_deliver1(v,c,customer_id,target):
  depot=nearby_depot(lorries[v]['location'])
  journey=nx.single_source_djikstra(g,source=lorries[v]['location'],target=depot,weight='weight')
  #for i in range(1,len(journey[1])):
  for i in range(1,len(journey[1])):  
    id=journey[1][i]
    index=custo_ids.index(id)
    if i<len(journey[1])-1:
       if(lorries[v]['stops']<3 and id in custo_ids and lorries[v]['current']>=demands[index]['demand']):
         lorries[v]['location']=demands[index]['id']
         lorries[v]['current']-=demands[index]['demand']
         lorries[v]['loc'].append([demands[index]['id'],-demands[index]['demand']])
         lorries[v]['stops']+=1
         del demands[index]
         del custo_ids[index]
         if(journey[1][i] in under_ids):
           index=under_ids.index(journey[1][i])
           del under_ids[index]
           del under_threshold[index]

         
       elif(id in custo_ids and lorries[v]['current']<demands[index]['demand'] and lorries[v]['stops']<3):
          lorries[v]['location']=demands[index]['id']
          demands[index]['demand']-=lorries[v]['current']
          
          lorries[v]['loc'].append([demands[index]['id'],-lorries[v]['current']])
          if(demands[index]['id'] in under_ids):
           indice=under_ids.index(demands[index]['id'])
           under_threshold[indice]['demand']-=lorries[v]['current']
          lorries[v]['current']=0
          lorries[v]['stops']+=1
    elif i==len(journey[1])-1:
          lorries[v]['location']=depot 
          load=lorries[v]['capacity']-lorries[v]['current']
          lorries[v]['loc'].append([depot,load])
          lorries[v]['current']=lorries[v]['capacity']
          lorries[v]['miles']+=journey[0]
          lorries[v]['stops']+=1
  
  deliver1(v,c,customer_id,target)

       


        




    



  

under_ids=[]
for i in range(len(under_threshold)):
  under_ids.append(under_threshold[i]['id'])


def possible_lorries(lorries,c):
    if(len(under_threshold)>0):

      target=under_threshold[c]['id']
      required=under_threshold[c]['demand']
    else:
      target=demands[c]['id']
      required=demands[c]['demand']
    vehicles=[]
    for i in range(len(lorries)):
      stops=0
      
      
      if(lorries[i]['current']>=required):
        to_customer=nx.single_source_dijkstra(g,source=lorries[i]['location'],target=target,weight='weight')[0]
      
        to_depot=nx.single_source_dijkstra(g,source=target,target=nearby_depot(target),weight='weight')[0]
        total_d=lorries[i]['miles']+to_customer+to_depot
        stops=lorries[i]['stops']+1
        
        if(total_d<=250 and stops<=5):
          vehicles.append(i)
      elif(lorries[i]['current']<required):
         depot=nearby_depot(lorries[i]['location'])
         depot_d=nx.single_source_dijkstra(g,source=lorries[i]['location'],target=depot,weight='weight')[0]
         to_customer=nx.single_source_dijkstra(g,source=depot,target=target,weight='weight')[0]
         to_depot=nx.single_source_dijkstra(g,source=target,target=nearby_depot(target),weight='weight')[0]
         total_d=lorries[i]['miles']+depot_d+to_customer+to_depot
         stops=lorries[i]['stops']+2
         if(total_d<=250 and stops<=5):
           vehicles.append(i)
    return vehicles

def pop1():
  left=[]
  def pers1():
    while len(under_threshold)>0:
      
      c=random.randint(0,len(under_threshold)-1)
      customer_id=under_threshold[c]['id']
      
      target=custo_ids.index(customer_id)
      options=possible_lorries(lorries,c)
      if(len(options)==0):
        left.append(under_threshold[c])
        del under_threshold[c]
        del under_ids[c]
        del demands[target]
        del custo_ids[target]
      else:
        
        v=options[random.randint(0,len(options)-1)]
        if(len(lorries[v]['loc'])==0):
          lorries[v]['current']=lorries[v]['capacity']
          lorries[v]['loc'].append([lorries[v]['location'],lorries[v]['capacity']])
        if(lorries[v]['current']>=under_threshold[c]['demand']):
          deliver1(v,c,customer_id,target)
        elif(lorries[v]['current']<under_threshold[c]['demand']):
          depot_and_deliver1(v,c,customer_id,target)
    while len(under_threshold)==0 and len(demands)>0:
      c=random.randint(0,len(demands)-1)
      target=c
      customer_id=demands[c]['id']
      options=possible_lorries(lorries,c)
      if len(options)==0:
        del demands[c]
        del custo_ids[c]
      else:
        v=options[random.randint(0,len(options)-1)]
        if(len(lorries[v]['loc'])==0):
          lorries[v]['current']=lorries[v]['capacity']
          lorries[v]['loc'].append([lorries[v]['location'],lorries[v]['capacity']])
        if(lorries[v]['current']>=demands[c]['demand']):
          journey=nx.shortest_path(g,source=lorries[v]['location'],target=customer_id,weight='weight')
          deliver1(v,c,customer_id,target)
        elif(lorries[v]['current']<demands[c]['demand']):
          depot_and_deliver1(v,c,customer_id,target)
        
        print(len(demands))
    print(lorries)
  return pers1()
      
       
pop1()



import networkx
       
  def possible_lorries(lorries,c):
    target=under_threshold[c]['id']
    vehicles=[]
    for i in range(len(lorries)):
      stops=0
      to_customer=nx.single_source_dijkstra(g,source=lorries[i]['location'],target=target,weight='weight')[0]
      
      to_depot=nx.single_source_dijkstra(g,source=target,target=nearby_depot(target),weight='weight')[0]
      
      if(lorries[i]['current']>=under_threshold[c]['demand']):
        total_d=lorries[i]['distances']+to_customer+to_depot
        stops=lorries[i]['stops']+1
        
        if(total_d>=250 and stops>=5):
          vehicles.append(i)
       elif(lorries[i]['current']<under_threshold[c]['demand']):
         depot=nearby_depot(lorries[i]['location'])
         depot_d=nx.single_source_dijkstra(g,source=lorries[i]['location'],target=depot,weight='weight')[0]
         to_customer=depot_d=nx.single_source_dijkstra(g,source=depot,target=target,weight='weight')[0]
         to_depot=nx.single_source_dijkstra(g,source=target,target=nearby_depot(target),weight='weight')[0]
         total_d=lorries[i]['distances']+depot_d+to_customer+to_depot
         stops=lorries[i]['stops']+2
         if(lorries[i]['distances']>=250 stops>=5):
           vehicles.append(i)
    return vehicles

import networkx as nx
g = nx.Graph()
edges=[]
edges.append(g.add_edge(131,673,weight=673))
print(edges)